# -*- coding: utf-8 -*-
"""
Solution to the Outcome Likelihood Problem.
Finding Mutations in DNA and Proteins (Bioinformatics VI) on Coursera.org
Week 4, code challenge #4
https://stepik.org/lesson/Hidden-Markov-Models-Code-Challenges-(Week-1)-11594/step/8?course=Stepic-Interactive-Text-for-Week-4&unit=9008
"""

import numpy as np
import networkx as nx
    
def viterbi_path_likelihood(transition_matrix_input,emission_matrix_input,states,emission_letters,emission_string):
    '''
    Outcome Likelihood Problem.
    
    Parameters
    --------
    transition_matrix_input: initial Transition matrix (string)
    emission_matrix_input: initial Emission matrix (string)
    states:  Collection of states of the HMM (list of strings)      
    emission_letters: The HMM's alphabet Î£ (list of strings)
    emission_string: A sequence of emitted symbols x = x1 . . . xn in an alphabet A generated by a k-state HMM with 
        unknown transition and emission probabilities
    
    Return
    --------
    The probability Pr(x) that the HMM emits x. (floating point number)
    '''
    def create_dicts_viterbi(transition_matrix_input,emission_matrix_input,states,emission_letters):
        '''
        Convert the inputted transition and emission matrices into dictionaries.
        '''
        num_emission_letters = len(emission_letters)
        num_states = len(states)
        transition_matrix_array = np.array(transition_matrix_input.split())
        emission_matrix_array = np.array(emission_matrix_input.split())
        transition_matrix = np.array([float(x) for x in transition_matrix_array if x not in states])
        emission_matrix = np.array([float(x) for x in emission_matrix_array if x not in states and x not in emission_letters])
        transition_dict = {}
        emission_dict = {}
        for i,state in enumerate(states):
            emission_values = emission_matrix[i*num_emission_letters:i*num_emission_letters + num_emission_letters]
            transition_values = transition_matrix[i*num_states:i*num_states + num_states]
            emission_dict[state] = emission_values
            transition_dict[state] = transition_values
        return transition_dict,emission_dict
    
    def create_viterbi_graph(transition_matrix_input,emission_matrix_input,states,emission_letters,emission_string):
        '''
        Create a weighted viterbi graph with weighted edges using the input parameters.
        '''
        viterbi_graph = nx.DiGraph()
        transition_dict,emission_dict = create_dicts_viterbi(transition_matrix_input,emission_matrix_input,states,emission_letters)
        for i in range(len(emission_string)+1):
            if i == len(emission_string):
                index = 0
            else:
                index = emission_letters.index(emission_string[i])
            for outgoing_state in states:
                emission_weight = emission_dict[outgoing_state][index]

                # add outgoing edges to source node (0)
                if i == 0:
                    incoming_state = ''
                    transition_weight = 0.5
                    viterbi_graph.add_edge(str(i),str(i+1) + outgoing_state,{'weight': emission_weight*transition_weight})       
                    
                # add remaining edges to viterbi graph
                else:
                    for incoming_state in states:
                        if i == len(emission_string):
                            transition_weight = emission_weight = 1
                            outgoing_state = ''
                            viterbi_graph.add_edge(str(i)  + incoming_state,str(i+1),{'weight': emission_weight*transition_weight})
                            continue
                        outgoing_index = states.index(outgoing_state)
                        transition_weight = transition_dict[incoming_state][outgoing_index]                      
                        
                        # add weighted edge (weight = transition probability * emission probability)  
                        viterbi_graph.add_edge(str(i) + incoming_state,str(i+1) + outgoing_state,{'weight': emission_weight*transition_weight})
        return viterbi_graph
    
    def calculate_scores_viterbi(viterbi_graph):
        '''
        Calculate the score for each node in the viterbi graph
        '''
        viterbi_graph.node['0']['score'] = 1
        sorted_nodes = nx.topological_sort(viterbi_graph)
        for node in sorted_nodes[1:]:
            predecessors = viterbi_graph.predecessors(node)
            score = 0
            
            # add up the scores for each prodecessor node multiplied by the edge weight
            for predecessor in predecessors:
                score += viterbi_graph.node[predecessor]['score']*viterbi_graph[predecessor][node]['weight']

            viterbi_graph.node[node]['score'] = score
        return viterbi_graph.node[str(len(emission_string)+1)]['score']  # return the score at the viterbi graph's 'sink'
    
    viterbi_graph = create_viterbi_graph(transition_matrix_input,emission_matrix_input,states,emission_letters,emission_string)
    sink_score = calculate_scores_viterbi(viterbi_graph)
    return sink_score
    
##########################################################################################
if __name__ == "__main__":
    emission_string = 'xzyyzzyzyy'
    emission_letters = 'x y z'.split()
    states = 'A B'.split()
    transition_matrix = '''A	B
    A	0.303	0.697 
    B	0.831	0.169'''
    emission_matrix = '''x	y	z
    A	0.533	0.065	0.402 
    B	0.342	0.334	0.324'''
    
    print viterbi_path_likelihood(transition_matrix,emission_matrix,states,emission_letters,emission_string)
